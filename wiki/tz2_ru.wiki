= QAPRS - версия Remus =

== Техническое задание ==

Разработать программу для работы в APRS сетях. Программа должна поддерживать весь 
функционал, необходимый для работы в сетях APRS. Программа должна иметь графический 
интерфейс для работы с картами, сообщениями и т. д. Настройка программы так же должна
производится с использованием графического интерфейса. Внутренняя структура программы 
должна позволять работу как с одним, так и с несколькими устройствами для передачи пакетов
сообщений. Для полноценной работы такой системы в многопортовой конфигурации, необходимо
реализовать поддержку цифровой ретрансляции пакетов (digi), работу моста между портами (gate),
работу моста в мировую сеть APRS (igate). Программа должна быть разработана на си++ с использованием
библиотеки QT4 для возможности переноса кода на другие ОС.

== Анализ технического задания ==

Для большей гибкости, в программе используется разделение кода на две части: а) код ядра системы и 
б) код поддержки интерфейса пользователя.

Ядро системы реализовывает в себе работу с аппаратными и программными устройствами передачи данных,
передачу данных, прием и обработку сообщений, запросов, а так же digi, gate и igate. Самостоятельно
сохраняет свои параметры, хранит все принятые и переданные пакеты, сообщения. В принципе, ядро 
обеспечивает весь необходимый для работы в сети APRS функционал, который не требует участия человека.
Таким образом ядро даже без интерфейса должно самостоятельно инициализироваться и начинать работу в сети.

Ядро реализуется как отдельный полностью изолированный класс. Взаимодействие с ядром производится через
порт TCP/IP текстовыми командами. Это позволит добиться большой гибкости, а так же возможности удаленного
управления работой ядра.

Пользовательский интерфейс используется для управления работой ядра. Технически класс ядра встраивается 
в код итерфейса пользователя, но взаимодействие с ним ведется через TPC/IP. Для пользователя должен отображаться
выбор ядра, с которым пользователь будет работать. По умолчанию интерфейс должен подключаться к ядру на
локальном компьютере.

Так же необходимо проработать возможность запуска ядра вообще без графического интерфейса в виде консольного
приложения или сервиса.

== Описание классов ядра ==

=== Порт ===

Под понятием порт подразумевается определенное устройство или способ передачи данных. Через порт передаются
и принимаются пакеты системы APRS. Примером порта может быть: KISS модем, подключенный к последовательному
порту компьютера (или программный эмулятор KISS модема в виде программы MIXW); порт ядра AGW; AXIP порт,
в котором пакеты APRS передаются через сети TCP/IP в виде UDP пакетов.

Порт или несколько портов входят в состав ядра. Ядро взаимодействует с портами стандартным способом, а порт
уже производит передачу или прием данных через специфическое устройство или другим способом. 

После создания порта он находится в отключенном состоянии. Ядро может установить параметры порта, сключить
его или отключить. Ядро через методы порта может определить его состояние - включен/отключен. В процессе
работы порт выдает ядру сигналы: об изменении своего состояния при этом ядро через методы 
считывает текущий статус порта(включен/отключен/ошибка); о факте приема и передачи пакета (сигнал содержит пакет); 
сигнал начала и окончания приема пакета (сигнал содержит флаг "идет прием пакета");
сигнал начала и окончания передачи пакета (сигнал содержит флаг "идет передача пакета");
сигнал изменения занятости линии передачи (сигнал содержит флаг "линия занята").

В ядре существует подсистема совместного доступа к устройствам. Работа с разделяемыми устройствами должна быть
реализована через эту подсистему.

Существует абстрактный класс порта, наследником которого должны быть все специфические порты, реализованные 
в системе. 

Класс содержит в себе методы:

 * Открытие порта (открывает порт с установленными параметрами);
 * Закрытие порта (закрывает порт);
 * Установка параметра порта (устанавливает параметры порта без изменения текущих, если порт открыт);
 * Обновление порта (в открытом порте устанавливает новые параметры взамен текущих);
 * Определение статуса порта (включен/отключен/ошибка);
 * Определение "идет прием пакета";
 * Определение "идет передача пакета";
 * Определение "линия занята";

APRS ядро работает с сообщениями, поэтому должно посылать и принимать APRS сообшения
в тех портах, которые используют для передачи данных пакет AX.25 сообщение APRS затем
кодируется в AX пакет и передается как пакет AX через метод передачи AX пакета. 
Такой подход позволит в дальнейшем реализовать в ядре работу со стандартным пакетом AX.25.

 * Передача APRS пакета через порт (Кому, ОтКого, ТекстСообщения);
 * Передача AX пакета через порт (Кому, ОтКого, СодержимоеПакета); 
 
Класс выдает сигналы:
 * Принят AX пакет через порт (Кому, ОтКого, СодержимоеПакета); 
 * Принято APRS пакета через порт (Кому, ОтКого, ТекстСообщения);

хронометрически сначала происходит прием пакета AX затем порт его декодирует в
сообщение APRS и формируется сигнал приема APRS сообщения
в некоторых портах (интернет порт, порт FLDIGI) уровень AX отсутствует и принятая
информация декодируется сразу как APRS пакет. Видимо тут надо искуственно формировать
пакет уровня AX. Возможно потребуется для эмуляции ядром QAPRS ядра AGW

 * Смена статуса порта (включен/отключен/ошибка);
 * Сигнал "идет прием пакета";    //два раза: при начале и при окончании
 * Сигнал "идет передача пакета"; //два раза: при начале и при окончании
 * Определение "линия занята"; //при смене занятости линии (пока в портах нигде не определить занятость линии)
 
Таким образом, имеется два сетевых уровня: верхний уровень (APRS) и нижний уровень (AX.25). Полноценная
поддержка AX.25 в ядре пока не предполагается. Реализуются только UI пакеты, которые не используют 
установки соединения между станциями (аналог UDP пакетов в сетях TCP/IP). Но порты должны позволять 
принимать и обрабатывать ядром пакеты на обоих уровнях. При использовании чистых AX.25 портов, таких как
AXIP, KISS, AGW не должно возникать никаких проблем. В то же время есть ряд портов, которые не используют
для передачи уровень AX.25 это такие порты, как порт содениения с Internet APRS сервером или порт 
соединения с FLDigi. В этих портах производится текстовый обмен APRS сообщениями сразу на этом уровне.
В таких портах, для поддержки будущей совместимости с AX.25 необходимо программно реализовывать переход 
на уровень AX.25. При приеме APRS сообщения нужно формировать AX пакет, формировать сигнал приема пакета AX,
а затем формировать сигнал приема пакета APRS. При передаче APRS сообщения через такой порт должна 
происходить реальная передача через этот уровень с формированием сигнала о передаче APRS сообщения, а затем
формирование покета AX с формированием сигнала о передаче пакета AX (передача AX через такой порт, 
естественно не происходит). Если же ядро попытается передат пакет AX через такой порт, то пакет необходимо
разобрать на предмет того, что он имеет формат UI, сформировать из него APRS пакет и передать. Все остальные
типы AX пакетов - игнорировать.

=== Ядро ===

Ядро - центр всей системы. Оно управляет работой портов, получия и передавая через них сообщения. 
Ядро выдает через порты маяк радиостанции, передает сообщения, получает сообщения (и при необходимости 
подтверждает прием), отвечает на APRS запросы, выполняет digi ретрансляцию пакетов, работает в качестве
моста gate и igate.

Ядро состоит из ряда подсистем, которые обеспечивают его работоспособность.

=== Ядро. Подсистема совместного доступа к устройствам ===

Некоторые порты в системе могут использовать устройства операционной системы, которые требуют монопольного доступа,
либо совместного доступа. Такими устройствами являются последовательные и параллельные порты, GPS приемники, звуковые платы. 
Используя эти устройства через данную подсистему, несколько портов смогут получить доступ к этим устройствам одновременно.

=== Ядро. Подсистема поддержки работы портов ===

При создании ядра оно автоматически загружает список портов, создает их, задает указанные ранее
параметры, а затем включает все порты.

По управляющим командам ядру, оно может выполнять следующие операции с портами:

 - Создание порта;
 - Удаление порта (вместе со всеми параметрами); 
 - Включение порта;
 - Выключение порта;
 - Задание определенного параметра работы порта;
 - Обновление порта (применение новых параметров порта происходит только при обновлении порта, 
    либо при повторном включении порта);

При работе с портами ядро получает от них различные сигналы.

При получении сигналов о смене статуса, и состояниях порта, данные события передаются клиентской части, 
которая работает с ядром, которая их будет использовать для своих нужд (например для графического отображения
статусов портов и т. д.).

При получении сигнала о приеме APRS пакета (вместе с самим пакетом) ядро его обрабатывает. Пакет помещается
с журнал пакетов(с пометкой принятый пакет). 

Если из пакета декодируется сообщение, то сообщение отдается на обработку в подсистему сообщений.

=== Ядро. Подсистема маяков станции ===

При работе в сети, станция показывает свое присутствие с помощью периодической 
передачи маяка. В многопортовой конфигурации, когда станция может работать
одновременно на нескольких диапазонах возникает проблема с разными правилами
относительно интервала маяка, символа станции и т. д. Для того, чтобы это избежать, существует подсистема
передачи маяков. Маяки передаются согласно настроенной таблице, в которой содержится список этих маяков.
На один и тот же порт (диапазон) может быть настроено несколько маяков. Это используется для того, чтобы
одна станция могла себя идентифицировать по-разному (например для поддержки специальных сервисов). В таблице 
маяков содержится порт, на который передается маяк; позывной, от имени которого передается маяк; 
координаты станции (широта и долгота); символ станции; UNPROTO ADDRESS по которому пойдет маяк;
комментарий к маяку (36 символов минус слово "{QAPRS}"); интервал маяка в секундах (!!!).

=== Ядро. Подсистема имен станции ===

Данная станция, при работе на нескольких портах или давая разные маяки, может работать разными позывными.
Для ответа на входящие пакеты станция должна определять, какие адресуются именно для этой станции 
(для приема сообщений, или какие либо системные позывные). Поэтому эта система должна хранить 
список позывных, которые будут определяться, как входящие для этой станции. На вопрос принадлежности
определенного позывного данной станции эта подсистема давать ответ ЛОЖЬ или ИСТИНА.

=== Ядро. Подсистема обработки принятых сообщений ===

Все принятые сообщения обрабатываются в этой подсистеме. 

При получении сообщения, сожержащего координаты станции, они декодируются, добавляются в журнал станций
с координатами, так же событие определения координат передается клиентской части.

Полученное текстовое сообщение, декодируется, добавляется в журнал сообщений (с пометкой принятое сообщение), 
клиентской части сообщяется о приеме сообщения.

Если текстовое сообщение адресовано данной станции (процедура определения принадлежности позывного 
данной станции), то сообщить клиентской части о том, что сообщение с id=NN адресовано данной станции.

Если сообщение не содержит message ID то ничего не делаем,
Иначе через подсистему передачи сообщений передать подтверждение приема сообщения (1 раз). Если удаленная
станция не получила подтверждения то она, возможно, отправит сообщение еще раз. Каждый раз для ядра это 
будет новое сообщение, на которое она еще раз будет отправлять подтверждение. В графической клиентской 
части, возможно, потребуется удалять дублирующиеся сообщения.

Если сообщение является одним из APRS запросов, то необходимо этот запрос соответствующи образом обработать
и ответ передать через подсистему передачи сообщений.

=== Ядро. Подсистема передачи сообщений в порт ===

Для начала эта подсистема должна просто отправлять сообщения в тот порт, на который это указано.

Сообщения должны заноситься в журнал сообщений (с пометкой переданное сообщение). Клиентской части
сообщается о передаче сообщения.

Сообщение перед передачей в канал преобразуется в APRS пакет и передается. Пакет APRS заносится в журнал
пакетов (с пометкой переданный пакет), клиентской части сообщается о передаче пакета APRS.

После реализации всех основных подсистем ядра, данная подсистема должна быть доработана.

Необходимо ввести поддержку виртуальных каналов передачи пакетов в порты. На каждый порт в системе будет 
назначен виртуальный канал, к которому он принадлежит. Канал представляет из себя очередь передаваемых
пакетов. Если порты передают информацию через разные аппаратные устройства, но завязаны какими-то наводками 
друг на друга, либо для передачи используется одно и то же аппаратное устройства, то такие порты объединяются
в один виртуальный канал. Пакеты извлекаются из канала (для передачи) в порядке их поступления (тип - очередь).
Каналу задается минимальное время между двумя следующими сообщениями. Возможно потребуется ввод приоритетов пакетов.
Должно задаваться максимальное количество пакетов, которое порт, подключенный к каналу может поставить в очередь.
В случае переполнения очереди - следующей пакет от порта будет заменять последний пакет от порта в очереди.
Такой подход позволит избежать переполнения очереди сообщениями и предотвратит монопольный захват канала.

Если в системе используются однонаправленные порты (одини порты только на прием, а другие только на передачу),
то потребуется установление определенных соответствий. Порту, который может работать только на прием, должен 
быть установлен порт, через который должны передаваться ответные сообщения. То есть, мы передаем сообщение в порт,
в ядре помечено, что этот порт "не для передачи", следовательно ядро найдет другой порт, который назначен для передачи
этому порту. Такой подход позволит работать асимметричным каналам, которые до этого не были испробованы на практике.

=== Ядро. Подсистема работы с клиентской частью ===

Взаимодействие ядра с клиентской частью производится через эту подсистему. Связь с клиентской частью производится через
TCP/IP содениение, для чего ядро открывает для прослушивания определенный порт. Для обмена используется формат XML.

Клиентская часто через эту подсистему осуществляет полный контроль над ядром и всеми его подсистемами. Через содениение с этой
подсистемой клиентская часть получает информацию о событиях, сообщениях, а так же сама формирует события, сообщения.

Вся нагрузка по формированию графического интерфейса пользователя ложится на клиентскую часть. Клиентская часть преобразует
команды пользователя в текстовые команды ядру. Сообщения ядра клиентская часть отображает пользователю в графическом и текстовом виде.


[http://code.google.com/p/qaprs/wiki/content_ru Вернуться к содержанию]